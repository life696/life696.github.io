# xC语言学习笔记

[TOC]





## 第一个C程序及其延伸

第一个C程序源文件名为first.c，内容如下：

```c
#include <stdio.h>     // 标准头文件，包含一些输入输出函数（我是注释）

int main(int argc, char *argv[])
{
    int a = 1;
    
    printf("a = %d\n", a); 
    printf("argc = %d\n", argc);

    for ( int i = 0; i < argc; i++ )
    {
        printf("%s\n", argv[i]);
    }

    return 0;
}
```

程序编译、运行的结果为：

![image-20201201110406302](Case_img/image-20201201110406302.png)

### 控制台

上图中黑色背景的窗口是控制台（运行之后弹出），程序和用户之间的交互界面（用户向程序输入数据，程序打印数据）

不同软件控制可能会不同，有的是弹出来的窗口，有的是包含在**IDE**中的一块





### 程序编译的过程

在.c文件中写好代码，就可以编译+运行了。

- 编译：把源代码翻译成一个可以运行的程序
- 运行：运行/执行这个程序

暂时可以认为写好之后只有两步：编译、运行。

其中编译包含：预处理、编译、汇编、链接等等。



**预处理**

```C
#include <stdio.h>
```

称之为预处理语句，在程序编译之前就要做的事。`include`把`stdio.h`中的代码包含进来。如果程序中使用了`stdio.h`中的内容，但是没有包含进来，可能会报错。

还有其他的预处理指令。

### main函数

`main()`是C程序的入口函数，不管多么复杂的程序，他的入口函数都是main函数，即，必先执行main函数，直到main函数结束（return 0）。

main函数可以有参数，在命令行编译C程序时， 可以传入：

- int argc：表示命令行参数的个数
- char *argv[]：是个字符指针的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。
  - argv[0]：程序名字
  - argv[1]：第一个参数
  - 最后一个参数是NULL

在Linux下使用gcc编译器，编译C程序，如下：

```shell
gcc xx.c    编译 
./a.out     执行
```

 默认生成一个a.out的可执行文件，也可以设置编译方式，需要了解makefile相关知识，本节为了说明main函数的参数，所以使用了gcc，其他的程序都可以在IDE（集成开发环境，像DECV++等等）中写，直接点击按钮编译。

执行结果：

```shell
zyl@book:~/Desktop/C$ ./a.out 
hello
argc = 1
./a.out
zyl@book:~/Desktop/C$ ./a.out nihao zhangsan
hello
argc = 3
./a.out
nihao
zhangsan
zyl@book:~/Desktop/C$ 
```

可以看出，程序本身也是一个参数，是第一个参数。

main函数另一种写法：

```c
#include <stdio.h>     

int main()   // 或者 int main(void)
{
    printf("hello\n"); 

    return 0;
}
```

只不过这样写就不能接收参数了，在IDE中这么写就可以（更具体的根据编译器版本确定）



### 程序格式

- C程序中，每一条完成的语句后面必须跟一个分号`;`，示意这条语句结束。
- `;;`连续两个分号，是没有问题的，第二分号表示，这是一个空语句
- 为了美观，同级别的语句之间要对齐；不同级别之间的语句要使用制表符`tab`键缩进
- 代码块：使用一对花括号括起来的`{}`



### 关键字

关键字是C语言本身定义好的名字/标识符，具有特殊的意义。C语言有32个关键字，还有新的标准中新加入的，就更多了

| **auto**     | **int**      | **double**   | **long**    |
| ------------ | ------------ | ------------ | ----------- |
| **char**     | **float**    | **short**    | **signed**  |
| **unsigned** | **struct**   | **union**    | **enum**    |
| **static**   | **switch**   | **case**     | **default** |
| **break**    | **continue** | **register** | **const**   |
| **volatile** | **typedef**  | **extern**   | **return**  |
| **void**     | **do**       | **while**    | **for**     |
| **if**       | **else**     | **goto**     | **sizeof**  |

这里仅对一些关键字进行说明，没有说明的，后面会用到，用到再说

- auto：声明自动变量，缺省时编译器一般默认为auto；最宽宏大量的关键字

- signed：表示有符号，有正负，有符号数，使用补码表示

  - 正数的补码为正数本身
  - 负数的补码为负数的绝对值各位取反后加1

- unsigned：表示无符号，只能是正数。当无符号数和有符号数混合运算时，会将有符号数转为无符号数后在进行计算，结果为无符号数

- int：声明整型变量（4字节）

- double：声明双精度变量

- long：声明长整型变量

- char：声明字符变量（1字节，8bit），无符号0 ~ 255，有符号-128 ~ 127

- float：声明浮点型变量（小数）

  | 类型   | 符号位        | 指数              | 尾数             |
  | ------ | ------------- | ----------------- | ---------------- |
  | float  | 1位（第31位） | 8位（第23-30位）  | 23位（第0-22位） |
  | double | 1位（第63位） | 11位（第52-62位） | 52位（第0-51位） |

  float和int都占用四个字节，但是float的范围比int大很多：

  - float能表示的具体数字的个数与int相同
  - float可以表示的数字之间不是连续的，存在间隙
  - float知识一种近似的表示法，不能作为精确的数使用
  - 由于内存表示法相对复杂，**float运算比int慢很多**

  注意：double和float具有相同的内存表示法，因此double也是不精确的，但是double占用的内存多，所以比float精确。

- union：声明联合数据类型变量；维护足够的空间来放置多个数据成员的“一种”，而不是为每一个数据成员配置空间，所有的数据成员具有相同的起始地址。一个union只配置一个足够大的空间来容纳最大长度的数据成员。

- enum：声明枚举类型变量；enum变量类型还可以给其中的常量符号赋值，如果不赋值则会从被赋初值的那个常量开始依次加1，如果都没有赋值，他们的值从0开始依次递增1

- static：声明静态变量；最名不符实的关键字

  - 修饰变量：静态全局变量，作用域从定义之处开始，到文件结尾处结束；静态局部变量，在函数体中定义时，只能在这个函数中使用，即使这个函数运行结束了，这个静态变量的值在函数下次使用时，仍然能用。

  - 修饰函数：函数前面加static使得函数成为静态函数，此时函数的作用域仅限于本文本，使得不同的人编写不同的函数时，不用担心自己定义的函数是否与其它函数同名。

    ```C
    #include <stdio.h>     
    
    void testStaticVal()
    {
    	static int a = 1; // 第一次到这里，声明a，赋值为1，
    					  // 再到这里，直接跳过，a上次a最终的值 	
    	a++;
    	printf("a = %d\n", a);
    }
    
    int main(void)
    {
    	testStaticVal();
    	testStaticVal();
    	testStaticVal();
    	testStaticVal();
    	
        return 0;
    }
    ```

    执行结果：

    > a = 2
    > a = 3
    > a = 4
    > a = 5

  

- register：声明寄存器变量；最快的关键字

- const：声明只读变量，其修饰的只读变量必须在定义的同时初始化（会单独列一节写）

- volatile：说明变量在出现执行中可被隐含地改变 ；最易变的关键字，volatile 是一种类型修饰符，用它修饰的变量表示可以被某些编译器未知的因素更改，比如操作系统，硬件或者其他线程等。

- typedef：用以给数据**类型**取别名

  ```
  typedef 已存在的类型 这个类型的别名
  ```

  ```C
  #include <stdio.h>     
  
  typedef int INT64；
  INT64 i1；  // 等价于 int i1；
  
  // C结构体起别名
  typedef struct Stu  
  {  
      int x;  
  }Stu, *pStu;  
  
  Stu stu1; // 结构体变量，等价于 struct Stu stu1;
  pStu stu2; // 结构体指针， 等价于struct Stu *stu2; 
  ```

  - typefef用于给一个已经存在的数据类型重命名
  - typefef本质上不能产生新的类型
  - typefef不能被unsigned和signed修饰
  - typefef要有分号
  - typefef增强了程序的可移植性

- extern：声明变量是在其他文件中声明，可以实现工程中的全剧变量（单独写）

- goto：无条件跳转语句（程序中尽量、**绝对不要使用**）

- sizeof：计算对象所占内存空间大小（字节数），是关键字，不是函数

  ```C
  #include <stdio.h>     
  
  int main(void)
  {
  	int a = 20;
  	char c;
  	
  	int aa[5];
  	
  	printf("len a = %d\n", sizeof(a));    // 4
  	printf("len c = %d\n", sizeof(c));    // 1
  	printf("len aa = %d\n", sizeof(aa));  // 20
  	
      return 0;
  }
  ```



### 定义和声明

定义和声明是有区别的，具体的在程序中体现的不明显。

- 声明：将一个变量引入程序，编译器不会为这个变量分配存储空间
- 定义：提供了一个实体在一个程序中唯一的描述，分配存储空间



```C
int a = 1; // 既是声明，也是定义

extern int a; // 引入一个其他文件中声明定义的一个变量，不分配空间，因为已经在其他地方分配好了
```



### 变量和数据

```C
int a = 1;   // a 就是一个变量，1是数据
```

内存存储数据的形式：内存中有很多个二极管，二极管有两种状态，通和断，分别用1和0表示。每个二极管叫1bit（1位），每8个bit组成一个新的单位，叫做字节（byte）。字节是内存中最小的存储单位。就像个十百千那样，字节也有进位，如下：

- 1KB = $2^{10}$B=1024B
- 1MB = $2^{10}$KB
- 1GB =  $2^{10}$MB

C中，变量声明后才可以使用，必须使用，变量的本质：

- 变量是一段实际连续空间存储空间的别名
- 程序中可以通过变量的名字来使用存储空间
- 变量是隶属于某一种数据类型的

C语言不具备显式的布尔（bool）类型，但是也有真和假的概念，C语言中任何非0值都是真，0值是假.

变量名字或标识符需要有意义，看到这个变量就要能知道这个变量表示的是什么。比如表示年龄就是age，数量就用num等等。如果无法写的清楚，就要在变量声明的时候加入注释，增强程序的可读性。

C中的变量名字或标识符可以以大写字母（A-Z）、小写字母（a-z）、数字（0-9）、下划线（_）来命名，但是第一个字符不能是数字

- num1：可以
- _nuM：可以（不建议使用）
- 2num_：不可以
- *num：不可以，不可以使用星

操作系统和标准标签等的名字都以一个或两个下划线字符开始，所以自己明明时候，尽量不使用下划线开头。

















## 类型转换

C中的数据类型可以转换：强制转化、隐式转换

```
 int i = (int)x； // 把变量x强制转换为int类型
 char ch = 10;
 int b = i;      // 隐式转换，把要给小范围的转换为大范围的
```

强制类型转换的结果：

- 目标类型能够容纳目标值：结果不变
- 目标类型不能容纳目标值：结果将产生阶段

不是所有的强制类型转换都能成功，当不能进行时，编译器会报错。

低类型到高类型的隐式转换是安全的，不会截断

高类型到低类型的类型转换是不安全的，导致不正确的结果

```
 int i = 2333;
 char ch = i;
 printf("%d\n", ch); // 29
```

其他：

- 大类型赋给小类型，可能溢出
- 小类型可以安全地赋值给大类型
- 浮点类型赋值给整型，会发生截断（小数部分丢失）
- 整型赋值给浮点类型，能够成功完成

## 内部连接和外部连接

编译单元：（中间文件）一个cpp文件在编译时，预处理器包含头文件，形成的含有所有必要信息的单个源文件。

链接：中间文件被编译成.o文件，不同的.o文件链接在一起生成可执行程序

- 内部链接：一个名称对于他的编译单元来说是局部的，并且在连接时不可能与其他编译单元中的同样的名称相冲突
- 外部链接：在一个多文件程序中，一个名称在链接时可以和其他编译单元交互，那么这个名称就有外部链接







## 字符和字符串

字符使用char声明，和int的区别只有范围大小之分，可以打印为整数，也可以打因为字符，C中没有专门用于存储字符串的变量类型，字符串呗存储在char类型的数组中。数组由连续的存储单元组成。

需要注意数组中的字符串的最后一个，存储的是**\0**字符，是空字符，C用这个空字符来表示这个字符串的结束。所以，数组的长度要存储的字符串长度多1。

例程1：

```C
#include<stdio.h>

int main()
{
    // 字符串赋值使用双引号，字符赋值使用单引号
	char str_1[5] = "abcd";
	char str_2[5];
	
	scanf("%s", str_2);
	
	printf("str_1 = %s\n", str_1);
	printf("str_2 = %s\n", str_2);
}
```

说明：str_1和str_2都只能保存5个字符的字符串。但是在不同的环境下运行结果却不同

- dev下：str_1长度大于等于5时，是正常的；str_2输入长度大于等于5时，也是正常的。

- 在cc下：str_1长度大于等于5时，是正常的；str_2输入长度大于等于5时，会报错

  > stack smashing detected : <unknown> terminated
  > Aborted (core dumped)

例程2：字符串长度，**strlen**函数

```C
#include<stdio.h>
#include<string.h>
int main()
{
    char str_1[5] = "abcyg";
    int a;    
    
    a = strlen(str_1);  // 返回字符串长度（）

    printf("str_1 = %s\n", str_1);

    printf("len str_1 = %d\n", a); 
}
```

说明，这个程序在gcc下也是没有问题的。str_1为“ab”时，len为2，她认为第三个是\0，结束了。





{:.bg-yellow-dark.text-white.p-2.box-shadow-large}
总结

一定要知道，数组的长度要比存储的字符串长度多1，如果数组长度固定了，字符串千万不能越界。

## scanf()和printf()

**scanf**()与**printf**()函数一样，都被声明在头文件stdio.h里。

**scanf**() 是格式输入函数，即按用户指定的格式从键盘上把数据输入到指定的变量之中。**scanf**() 从标准输入流stdin中读内容的通用子程序，可以说明的格式读入多个字符，并保存在对应地址的变量中。

**printf**()是把变量的值、字符串等向控制台输出打印，在控制台上会显示出来。

例程1

```C
#include<stdio.h>

int main()
{
	int a, b, c;
	
    // scanf("%d %d %d", &a, &b, &c);  // %d之间可以有空格
	scanf("%d%d%d", &a, &b, &c);	
	printf("a = %d, b = %d, c = %d\n", a, b, c);
}
```

说明：该程序允许输入三个整数，并将其打印出来，没有输入完时，会卡在scanf函数。

- 输入方式1：每输入一个整数，就按下回车，直到第三个数输入完按下回车，**scanf**函数就会执行完，继续向下执行。
- 输入方式2：输入三个整数，每个数之间有空格

例程2：格式化输出

```C
#include<stdio.h>

int main()
{
	int a = 10;
	char c = 'a';
	float f = 10.2;
	
	printf("a = %d, c = %c, f = %f", a, c, f);
}
```

说明：

- %d：整型输出（默认十进制）
- %c：输出字符
- %f：输出浮点型

例程3：输出其他进制

```C
#include<stdio.h>

int main()
{
	int a = 10;
	char c = 'a';
	float f = 10.2;
	
	printf("a的十进制 = %d\n", a);
	printf("a的八进制 = %0o\n", a);
	printf("a的十六进制 = %0x\n", a);
	printf("a的十六进制 = %05x\n", a); // 5表示显示5位 	
}
```





## 待整理

### C联合体拆解高低字节

## 2、分离高低字节

单片机中经常会遇见分离高低字节的操作，比如进行计时中断复位操作时往往会进行

> (65535-200)/256,
>
> (65535-200)%256

这样的操作，而一个除法消耗四个机器周期，取余也需要进行一系列复杂的运算，如果在短时间内需要进行很多次这样的运算无疑会给程序带来巨大的负担。

其实进行这些操作的时候我们需要的仅仅是高低字节的数据分离而已，这样利用联合体我们很容易降低这部分开销。

**代码：**

***\*左右滑动查看全部代码>>>\****

```
union div
{
    int n;     // n中存放要进行分离高低字节的数据
    char a[2]; // 在keil c中一个整形占两个字节，char占一个字节，所以n与数组a占的字节数相同
}test;
test.n = 65535-200; // 进行完这句后就一切ok了，下面通过访问test中数组a的数据来取出高低字节的数据
TH1 = test.a[0];    // test.a[0]中存储的是高位数据
TL1 = test.a[1];    // test.a[1]中储存了test.n的低位数据
```

联合体内数据是按地址对齐的。具体是高位数据还是低位数据要看平台的大小端模式，`51`是大端，`stm32`默认是小端，如果其他编译器还请自测。

仅仅用了一条减法指令就达到了除法、取余的操作，在进行高频率定时时尤为有用。



