# 待整理

[TOC]







## 算法



#### 循环访问数组（前到后，后到前）

从前往后：下一个索引值=（当索引值+1）%总个数，比如一共有4个元素，编号0,1,2,3

> 当前是编号=0，下一个编号=（0+1）%4=1
>
> 当前是编号=1，下一个编号=（1+1）%4=2
>
> 当前是编号=2，下一个编号=（2+1）%4=3
>
> 当前是编号=3，下一个编号=（3+1）%4=0

从后往前：上一个索引值=（当索引值-1+总个数）%总个数，比如一共有4个元素，编号0,1,2,3

> 当前是编号=3，上一个编号=（3-1+4）%4 = 2
>
> 当前是编号=2，上一个编号=（2-1+4）%4 = 1
>
> 当前是编号=1，上一个编号=（1-1+4）%4 = 0
>
> 当前是编号=0，上一个编号=（0-1+4）%4 = 3



#### 经典算法

##### 排序算法

选择、插入、气泡、希尔、归并 、快速  、

###### 选择排序

将要排序的对象分作两部份，一个是已排序的，一个是未排序的，从后端未排序部份选择一个最小值，并放入前端已排序部份的最后一个。

排序前：70 80 31 37 10 1 48 60 33 80

[1] 80 31 37 10 70 48 60 33 80 选出最小值1

[1 10] 31 37 80 70 48 60 33 80 选出最小值10

###### 插入排序

像是玩朴克一样，我们将牌分作两堆，每次从后面一堆的牌抽出最前端的牌，然后插入前面一堆牌的适当位置

排序前：92 77 67 8 6 84 55 85 43 67

[77 92] 67 8 6 84 55 85 43 67 将77插入92前
[67 77 92] 8 6 84 55 85 43 67 将67插入77前

###### 气泡排序

最大的元素会如同气泡一样移至右端，其利用比较相邻元素的方法，将大的元素交换至右端，所以大的元素会不断的往右移动，直到适当的位置为止。基本的气泡排序法可以利用旗标的方式稍微减少一些比较的时间，当寻访完阵列后都没有发生任何的交换动作，表示排序已经完成，而无需再进行之后的回圈比较与交换动作

排序前：95 27 90 49 80 58 6 9 18 50

27 90 49 80 58 6 9 18 50 [95] 95浮出
27 49 80 58 6 9 18 50 [90 95] 90浮出



## 汇编







有时候经常用到汇编的指令，不好记忆，而且用得少，不经常写，有的即使记住了，过段时间也是忘记了，而且有时不用必须自己会写，别人写的能看懂就行，把别人写的拿来直接用，所以用此篇文章做个常用汇编指令的记录，方便以后翻阅。OK，开始了

### MOV、LDR、STR指令

MOV，赋值、移动数据指令

```assembly
MOV R0,#0      @ 把立即数0赋值给寄存器R0，就是把立即数0放在寄存器R0里面，#数字，表示立即数。
MOV R0,[R1]   @ 把寄存器R1保存的数据作为地址，这个地址里的内容送到R0

MOV [R0],R1   @ 把寄存器R1的数据送到R0保存的地址所指向内存
```

LDR，读内存、伪指令移动数据类似MOV

伪指令不是真正的指令，最终会被拆分为几条真正的指令

```assembly
LDR R0, [R1]  @ 假设寄存器R1中保存的数据是x，读取地址x上的数据到寄存器R0中（4字节）

LDR R0, =#0x2345678  @ 将数据0x2345678，放入到寄存器R0中（同MOV，可操作的范围比MOV大）

```

STR，写内存

```assembly
STR R0, [R1]  @ 假设寄存器R1中保存的数据是x，把寄存器R0中的数据写到地址x的内存上（4字节）
```

MOV和LDR的区别

如果ARM芯片是32位的，每条汇编指令都占用32bit（4字节）。以MOV来说，这32bit中，有一部分表示MOV指令名字，一部分表示源操作数，一部分表示目的操作数，那么操作数就是有范围的（具体范围见手册），MOV不能移动超出范围的操作数（能操作的叫做立即数）。

使用LDR可以移动超出MOV范围的数字。需要使用=。LDR是伪指令，最终被拆分成几条真正的汇编指令，可以把.S文件编译成.o文件再链接成.elf汇编文件，把elf文件反汇编得到反汇编文件，就可以看到具体过程



### 关于寄存器

关于CPU的寄存器可以参考手册《ARM指令集E004armproc》

![](assembly_img/register.png)

- pc寄存器：程序计数器，把一个地址写入到sp寄存器时，程序就跳到这个地址去执行。pc的值为当前地址+8
- lr：连接寄存器，保存返回地址
- sp：栈指针寄存器

流水线：当前执行地址A的指令，同时在对地址A+4的指令进行译码，同时在读取地址A+8的指令。所以pc的值等于当前地址+8





### B、BL













### 堆栈指针寄存器 SP 

​	堆栈是一种具有“后进先出”（LIFO---Last In First Out）特殊访问属性的存储结构。堆栈一般使用RAM 物理资源作为存储体，再加上LIFO 访问接口实现。 堆栈的实现方法：

​	在随机存储器区划出一块区域作为堆栈区，数据可以一个个顺序地存入（压入）到这个区域之中，这个过程称为‘压栈’（push ）。通常用一个指针（堆栈指针 SP---Stack  Pointer）实现做一次调整，SP  总指向最后一个压入堆栈的数据所在的数据单元（栈顶）。从堆栈中读取数据时，按照堆栈 指针指向的堆栈单元读取堆栈数据，这个过程叫做 ‘弹出’（pop ），每弹出一个数据，SP 即向相反方向做一次调整，如此就实现了后进先出的原则。

​	堆栈是计算机中广泛应用的技术，基于堆栈具有的数据进出LIFO特性，常应用于保存中断断点、保存子程序调用返回点、保存CPU现场数据等，也用于程序间传递参数。

### 3 程序计数器 PC

​	他是专门用于在CPU取指期间寻址程序存储器，PC总是总是保持着下一条要执行的指令的16位地址。CPU总是按照PC的指向对指令序列进行取指、译码和执行，也就是说，最终是PC 决定了程序运行流向。程序通常是顺序执行的，当取出一个指令后PC值自动加一，如果执行跳转指令子程序调用或者返回或者中断时，要把跳转到的地址赋给PC。



## Pyhton编程基础

[TOC]



### 安装Pyhton环境

根据系统不同，有不同的选择：

- windows下，安装anaconda，包含了很多第三方库，使用其中的spyder编辑器，安装时下一步即可
- linux（ubuntu为例）：
  - 安装anaconda，同windows，anaconda是跨平台的
  - 安装pip，使用pip安装更多的第三方库，然后安装sublime编辑器编写代码，使用命令行编译程序

如果有多个Python环境（不同版本的Python、不同的第三方库），可以在安装PyCharm，可以创建基于不同环境的工程（参加Python相关配置）

### 变量和数据类型

Python的变量使用直接赋值使用，不需要定义声明，但是变量也是有类型的，整型和浮点型等等。Python中的主要数据类型如下：

- 列表：类似C语言中的数组，但是一个列表中可以存储不同类型的数据，可以修改列表元素，使用中括号`[]`，例如：[1,2,"qqq"]
- 元组：和列表基本相同，但是元素不能修改，使用圆括号定义`()`
- 字典：字典中存储的是键值对，由键找到值，使用花括号定义`{}`

### 列表

列表的特点：

- 使用中括号定义`[]`
- 元素可以修改
- 元素的类型可以不同
- 元素从0开始编号
- 可以切片操作

#### 定义列表

使用时，直接定义，或者先定义一个空的列表

```python
a = [1, "str", 2.1]   # 使用时，直接定义

b = list()    # 定义一个孔列表
 
c = []   # 也是一个空列表，还是使用list()的方法较好
```

#### 列表追加元素

使用`append()`函数，在末尾追加一个元素

```python
a.append(3)   # 追加一个整型3
```

### 元组

元组的特点和列表基本相同，不同的是，元组的元素不可修改，定义之后，就不能修改了



### 字典



### 切片操作

列表和元组都可以切片。切片操作是指操作列表中某一段数据。

```python
a = [1, 2, 3, 4, 5]
# 表示编号2开始，到编号4终止，不包括最后一个，个数就是4-2=2
print(a[2:4])  # [3, 4]

# 不指定位置，就默认是起始或者终止
print(a[:4])  # [1, 2, 3, 4]
print(a[1:])  # [2, 3, 4, 5]
```

多维数组有更灵活的切片方式（以后再学）



### 流程控制

### for

for可以用来，遍历迭代器，从可迭代的数据中逐个取出元素，

使用`for`遍历列表

```python
a = [1, 2, 3, 4, 5]

for i in a:  # 取出a中的元素，给i，然后再取下一个
    print(i)
```

执行结果如下：

> 1
> 2
> 3
> 4
> 5

C语言的中的写法为：

```c
for ( int i = 0; i <　5; i++ )
    printf("%d\n", a[i]);
```

#### `range`函数

`range(x)`，表示从0到x-1的整数

**代码1**：

```python
for i in range(3):  # 0 1 2
    print(i)  
```

> 0
> 1
> 2

**代码2**：

```Python
a = [1, 2, 3, 4]

for i in range(len(a)):
    print(a[i])
```

> 1
> 2
> 3
> 4

### if

用来判断

**代码1：**

```python
a = 3

if a > 2 and a < 10:
    print("2-10之间")
```

和C中的操作符不同，Python操作符如下：

- 与：and
- 或：or
- 非：not，（`if not a:`）



























