# 嵌入式linux基础

[TOC]

### 参考资料

《ARM体系结构与编程》杜春雷

《嵌入式Linux应用程序开发标准教程》

《UNIX 高级环境编程》

《深入理解Linux内核》

《构建嵌入式linux系统》

《devicetree-specification-v0.2.pdf》设备树官方文档

《LINUX 设备驱动程序》（第三版）ldd3 



### 待整理

- linux 文件的操作
- 



### 其他

- 虚拟机和USB3.0：经过测试发现，重要打开虚拟机，USB3.0的接口就识别不到设备，键盘、鼠标什么都识别不到
- usr 不是 user 的缩写，而是 Unix Software Resource 的缩写，也就是 Unix 操作系统软件资源目录。
- make distclean和make mrproper等指令使内核恢复到刚解压的状态（可以查看顶层的Makefile文件）（mrproper一种洗涤剂）
- make xx_defconfig 会生成 .config文件
- tree命令查看文件树
- 内核的实际是函数的start_kernel()函数
- linux 串口：/dev/ttyS0，/dev/ttyS1 分别表示串口1和串口2
- 

### 一些Linux软件

- TFTP
- NFS
- 1

### Linux命令

**命令行机制** 

在命令行输入“ls”并且回车就会显示当前路径下的文件（文件夹、可执行程序都属于文件），机制如下：

在键盘上按下 l ，那么这个 l 就会发送给 shell 程序，并且在终端显示出 l ，输入 s 类似。
按下enter，回车也会发送 shell ，enter之后，shell就会根据输入的内容中第一个字符串（有的命令可能有参数，ls -l，是找ls，不是 ls -l 命令）去默认的路径中找到相应的可执行程序，并且执行。这个默认的路径由环境变量PATH指定，或者自己直接指定。
环境变量是很多个路径的集合，查看打印环境变量用：echo \$ PATH，添加新的环境变量用：export PATH = $PATH:/home/mydir，就是指定新的环境变量为：原来的加上想要加进来的。

有时候会出现：Command not found，原因如下：

PAT所指定的路径中没有这个命令，把这个命令所在的路径添加进来即可解决。
这个命令不是可执行程序。
如果没有可执行权限，加上即可：chmod +x 文件

**介绍常用命令**

- ls：查看当前路径下内容，

  - -l：显示长信息
  - -a：显示所有文件
  - -h：文件以K、M、G大小显示
- pwd：显示当前路径
- cd：切换路径

  - cd ~ ：切换到家目录，~代表家目录
  - cd - ：进入上次的目录
  - cd ..：切换到前一级路径
  - cd ../..：切换到前前一级目录
- mkdir：创建目录（文件夹），

  - mkdir -p dir1/dir2 : 连续创建多级目录，如果父目录不存在，加 -p 选项，会自动创建
- rmdir：删除目录，不能删除非空目录
- rm：删除文件，rm  -rf dir_a（删除目录）

  - -i ： 删除文件前，询问是否删除
  - -r ： 递归删除
  - -f ： 强制删除，例如： rm -f 删除文件夹
- mv：移动或者修改文件名、目录名、路径。mv 旧 新
- cp：复制文件，cp 1.txt 2.txt /home
  - 复制目录：cp  -rfd dir_a dir_b   循环递归
  - r：recursive，递归地，即复制所有文件
  - f：force，强制覆盖
  - d：如果源文件为链接文件，也只是把它作为链接文件复制过去，而不是复制实际文件
- touch：创建文件
- chmod +x 文件：给文件加上可执行权限
- chgrp：改变文件所属用户组
- chown：改变文件所有者
- chmod：改变文件的权限
- ~：表示家目录
- touch：创建新文件
- cat：显示文件的内容到终端，-n显示行号
- clear：刷新屏幕，到新的一页，之前的内容还在
- reset：重启终端，关闭再打开，之前的内容没了
- man、info、help：查看命令的用法，多用man，man有9册，每册针对不同的内容，要知道。
- find：查找文件，find 目录名 选项 查找条件，没有指定目录就是当前目录下，或者使用点 .
  - find  /  -name "test1.txt"  ，根目录/下查找名字为test1.txt文件
- grep：查找文件中符合条件的字符串，
  - 格式：grep \[选项]\[查找模式][文件名]
  - grep -rn "字符串"  文件名    ：如果文件名是*，表示当前目录下所有文件
  - -r  递归查找，recursive
  - -w  全字匹配
  - -n  显示行号，number
- file：识别文件类型，格式：file 文件名
- which和whereis：查找命令或应用程序的所在位置，格式：which  命令名或者应用程序名
  - which  命令名/应用程序名
  - whereis  命令名/应用程序名
  - which pwd  //定位到/bin/pwd
  - whereis pwd  //可得到可执行程序的位置和手册页的位置
- gzip 和 bzip2：无损压缩，单个文件
- tar：无损压缩，多个文件、目录
- ifconfig：网络命令
  - -a ：显示所有网卡接口
  - up：激活网卡接口 
  - down：关闭网卡接口
  - address：xxx.xxx.xxx.xxx，IP地址
  - 设置IP：sudo ifconfig ens160 192.168.1.137
- ping：测试网络
- file：查看文件类型。file 文件名
- top：动态显示系统中运行的程序（一般为每隔5s）
- ps：显示当前系统中由该用户运行的进程列表ps 
- kill：输出特定的信号给指定PID（进程号）的进程
- 
- 1

















### Vi编辑器的使用

Vi编辑器三个模式：一般模式、编辑模式、命令行模式，刚进入编辑器时处于一般模式：

- 一般模式：光标移动
- 编辑模式：输入内容
- 命令行模式：搜索、查找

不管出于什么模式，按下ESC键都会进入到一般模式

![](linux_img/Vi.png)

**退出**

按下ESC，进入一般模式，输入分号 `:`，进入命令行模式，就可以退出了

- wq：保存退出
- q!：不保存，退出

**编辑**

刚进入vi，默认处于“一般模式”

-  i：insert, 表示在光标前开始插入文本
- a：after，表示在光标后开始插入文本
- o：other，表示在当前行之下新建一行，可以在行首输入字符

**vi编辑器的配置**

- 加入行号：vi /etc/vim/vimrc ，最后一行加上`set nu` 



































### shell编程

shell实现了用户和操作系统内核的交互，Linux系统的终端就是shell，Linux 默认的 Bash

- $ ： Shell 提示符
- \# ： 根用户（root）提示符。

linux命令 ls、cd等都是shell程序。



shell脚本是一个可执行程序，不需要编译，可以直接执行。

```shell 
#! /bin/sh     
# shell中使用 #号注释
# 第一行：#!后面跟的是要使用的shell的路径（Bourne  Shell，C shell等等）
# 本脚本是一个shell程序，由/bin 目录下的 Bash 程序来解释执行
```

#### shell命令

- 内建命令：shell 本身执行的命令，cd、ls、echo
- shell 函数：
- 外部命令：



#### 其他

- echo：输出函数，自带一个换行符
- $PATH：是一个以冒号分隔的目录列表

#### 变量

所有变量的取值都是一个字串，有：

- 系统变量：对参数判断和命令返回值判断会使用
- 环境变量：主要是在程序运行的时候需要设置
- 用户变量：编程中用得多

引用变量，使用$

**系统变量**

- $ # ：保存程序命令行参数的数目。
- $ ?  ： 保存前一个命令的返回值。
- $ 0  ：当前程序名。
- \$ *  ： 以（"$1 $2…"）的形式保存所有输入的命令行参数。
- \$ @ ：以（"$1""$2"…）的形式保存所有输入的命令行参数。
- \$ n  ： \$1 为命令行的第一个参数，$1 为命令行的第二个参数，依次类推。

```shell
#! /bin/sh

# Note: xxxxxx

echo "the script is : $0"    
echo "the number of parameters is :$#" 
echo "parameters are:$@"   
echo "no.1:$1"
echo "no.2:$2"
```

执行结果如下：

```shell
book@100ask:~/Desktop$ ./msh abc dfe
the script is : ./msh
the number of parameters is :2
parameters are:abc dfe
no.1:abc
no.2:dfe
book@100ask:~/Desktop$
```

**环境变量**

Shell 环境变量是所有 Shell 程序都会接受的参数。Shell 程序运行时， 都会接收一组变量，
这组变量就是环境变量，都是以串的形式存在的，常用的 Shell 环境变量如下

- PATH：决定了 Shell 将到哪些目录中寻找命令或程序。
- HOME：当前用户主目录的完全路径名。
- HISTSIZE：历史记录数。
- LOGNAME：当前用户的登录名。
- HOSTNAME：指主机的名称。
- SHELL：Shell 路径名。
- LANGUGE：语言相关的环境变量，多语言可以修改此环境变量。 
- MAIL：当前用户的邮件存放目录。
- PS1：主提示符，对于 root 用户是#，对于普通用户是$。
- PS2：辅助提示符，默认是“>” 。
- TERM：终端的类型。
- PWD：当前工作目录的绝对路径名

```shell
#! /bin/sh

echo "$PWD"    # $变量名，引用这个串
```

执行结果，打印如下内容：

```
/home/book/Desktop
```

**用户变量**

可以使用任何不包含空格字符的字串来当做用户变量名称，使用`=`给变量赋值，`=`两边**不能有空格**。

```shell
#! /bin/sh

v1="abc"
v2=10

echo $v1         # 使用$引用变量，
echo $v2
```

执行结果如下：

```
abc
10
```

#### 流程控制

**if 语句**

```shell
#! /bin/sh

v2=11

if [ $v2 = 10 ]   # 使用一个 = 两边要有空格，和C不一样， 
then
        echo "v2 = 10"
else
        echo "v2 != 10"
fi
```

执行结果，打印：v2 != 10























### GCC 编译器

**选项**

- -E  预处理，开发过程中想快速确定某个宏可以使用“-E  -dM”
- -c  把预处理、编译、汇编都做了，但是不链接
- -o  指定输出文件
- -I  指定头文件目录
- -L  指定链接时库文件目录
- -v 
- -g：调试选项
- -O：优化选项
- -O2：比-O 更幅度更大的优化，但是编译的慢
- -Wall：基本打开了所有需要注意的警告信息

**制作动态库**

```makefile
gcc -c -o main.o main.c
gcc -c -o sub.o sub.c
gcc -shared  -o libsub.so  sub.o  sub2.o sub3.o(可以使用多个.o 生成动态库)
gcc -o test main.o  -lsub  -L /libsub.so/所在目录/
```

运行：

1. 先把 libusb.so 放到 PC 或板子上的/lib 目录，然后就可以运行 test 程序。

2. 如果不想把 libusb.so 放到/lib，也可以放在某个目录比如/a，然后如下执行：

   ```
   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/a 
   ./test
   ```

**制作静态库**

```
gcc -c -o main.o main.c
gcc -c -o sub.o sub.c 
ar  crs  libsub.a  sub.o  sub2.o sub3.o(可以使用多个.o 生成静态库)
gcc  -o test main.o libsub.a (如果.a 不在当前目录下，需要指定它的绝对或相对路径)
```

运行：不需要把静态库 libsub.a 放到板子上。

**依赖**

**生成依赖**

```
gcc -E main.c // 查看预处理结果，比如头文件是哪个
gcc -E -dM main.c > 1.txt // 把所有的宏展开，存在 1.txt 里

// 生成依赖文件 abc.dep，后面 Makefile 会用
gcc -Wp,-MD,abc.dep -c -o main.o main.c 
```







### Makefile基础

**待整理**

- 

**参考文档**

a. 百度搜 "gnu make 于凤昌"
b. 官方文档: http://www.gnu.org/software/make/manual/

**Makefile功能**

Makefile中的内容指定了工程中若干h文件、c文件的编译规则。使用`make`命令来执行Makefile文件，即可编译整个工程，有三条编译规则：

- 如果这个工程没有被编译过，那么所有的C文件都要编译并且链接。
- 如果这个工程被编译过，但是后来又有几个C文件被修改过，那么只编译修改过的C文件，并且重新链接。
- 如果这个工程被编译过，但是后来有几个头文件被修改了，那么重新编译包含了那些头文件的C文件，重新链接。

有一个“时间戳”的东西，能够检测文件是否有被修改。检测依赖和目标的，依赖比目标新，就认为是源文件修改过了，就要重新编译

**Makefile基本结构**

基本结构如下

```makefile
target ... : prerequisites ... 
	command 
...

目标：先决条件（依赖）
　　命令

clean:
	rm -f *.o 
```

- target：目标文件，可以是.o文件，也可以是可执行文件
- prerequisites：先决条件，是这个目标的依赖，需要的材料，可能有多个
- command：命令，是具体的实现过程。需要注意的是，目标不缩进，而命令前是一个Tab键

**一个示例**

```makefile
ab.bin：1.o 2.o
	gcc -c -o ab.bin 1.o 2.o
1.o：1.c a.h
	gcc -c -o 1.o \
	1.c
2.o：2.c b.h
	gcc -c -o 2.o 2.c
clean：
	rm -f *.o ab.bin
```

`clean`：在这个工程下，执行 make clean 就可以删除掉之前编译过程中产生的文件，可以自己设置要删除什么。这个用法中，clean也是一个目标，但是他没有先决条件，没有依赖，执行之后也就不生成相应文件，rm 是删除指令，-f 是说不管要删除的都东西有没有，都不报错，其实就是说如果有就删除，没有就拉倒。后面的 *.o 的意思是所有 .o 文件，当然如果不想删除所有.o文件，也可以单独指定，也可以删除别的文件，比如目标文件，只要是编译产生的，就可以删除，执行完了 make clean 之后，要回到没有编译时候的状态。

`clean`的更稳的做法是使用一个伪目标，如下

```makefile
.PHONY : clean
clean : 
	rm -f *.o 
```

`.PHONY`表示 clean 是一个“伪目标”

**常见符号表达**：

- $^ 表示所有依赖
- $< 表示第一个依赖
- $@ 表示目标
- \ 　反斜杠，换行的意思，如果这行内容太多，可以在下一行继续输入

**Makefile工作方式**

首先，执行 make 之后，他会找到这个目录下的Makefile文件，如果没有就报错了。找到之后进去，会找到第一个目标，然后把他当作最终的目标文件，再找到他的依赖，他的生成方式，依赖的依赖，一层一层的去做。直到最终生成第一个目标文件，如果这个过程中有错误，比如某个目标的依赖找不到，就退出且报错。如过我门输入的不是 make 而是 make XXX ，那就直接找到 XXX 这个目标，不管他是第几个，就找到他，以他为最终目标，然后一层一层的执行，最终生成他。

找到XXX之后，可能这个 XXX 并没有依赖文件，没有依赖文件的话那就不是生成这个目标了，相当于原材料都没有。那他做的就是执行下面的命令了，举个例子：clean

对于clean这种，没有直接关联或者间接关联的文件，那他后面的命令就不会自动执行，不过我们也得让他执行啊，用 make clean 这个，即执行clean。

**Makefile中的变量**

如果一个工程很大，有很多的.o文件，用这些.o文件生成可执行文件时候，很容写乱，而且如果在添加或者删除某一些.o文件的话操作起来和不舒服，那么我们就把所有的.o文件都放在一个变量里面，以后只要想动.o文件，我们就去修改这个变量就行了。举个例子：

```
abc:1.o 2.o 3.o 4.o \   
5.o 6.o
　　cc-o abc 1.o 2.o 3.o 4.o \
5.o 6.o
```

程序中的“/”是换行，下一行和他连接着。这些.o文件用了两次，很容易写错，除非是粘贴复制哈哈。我们对上面这个程序做一些改进

```
obj = 1.o 2.o 3.o
	abc： $(obj)
cc -o $(obj)
```

第一句是定义这个变量，$(变量名) 使用这个变量名。这么写就好看点，以后只需要动obj就可以了，这个obj是随意命名的。

以上都是特别基础的东西，了解了这些，就能看明白最简单的Makefile，然后逐渐的深入，学习更多更复杂的用法。一点一点积累。

- 即时变量（简单变量）：赋值时直接确定变量，A：=xxx    
- 延时变量： 用到的时候才确定，B = yyy 
- 延时变量：使用 ?= ，如果是第一次才起效，如果在前面该变量已经定义，则忽略这句
- 附加变量：使用 +=，他的类型取决于前面的定义

一个示例

```makefile
A := $(C)   # 此时还没有C，所以Ａ为空
B  = $(C)　 # B是c，只要使用到B的时候，C有值B就不为空
C = abc
C ?= abc # 已经定已过，此句忽略
all:
	@ehco A = $(A)  # 空
	@ehco B = $(B)  # abc
#C = abc   # 放在这里，B也有值
```











**自动推倒**

GNU的make很强大，他可以自动地推导文件以及文件依赖关系后面的命令。那就没有必要在每个.o文件后面都加上.c文件，不写也行。比如，看到了XX.o会自动的加入XX.c依赖的。

make时，如果不指定目标，那他就找到第一个目标，以他为最终的目标执行，如果指定了某个目标，那就以指定的那个目标执行。

```makefile
cd mm;make clean  
```

先进入到mm目录下，在执行make clean



**通配符**

通配符%，可以表示任意的字符串

```makefile
test : a.o b.o
	gcc -o test a.o b.o
%.o : %.c
	gcc -c -o $@ $^ 
```

目标test，需要a.o和b.o文件，第三行表示：只要是.o文件，都需要同名的.c文件生成。



**假想目标**

```makefile
.PHONY : clean
clean : 
	rm -f *.o 
```

.PHONY表示clean 是一个“伪目标”，使用make clean即可执行clean下的命令



**函数** 

**foreach函数**

遍历

```makefile
A = a b c
B = $(foreach f, $(A), $(f).o)

all:
	@echo B = $(b)
```

遍历A中的内容，把每一个（空格隔开的）都加上.o后缀

**filter函数**

过滤

```makefile
C = a b c d/
D = $(filter %/, $(C))   # 取出符合格式的值
E = $(filter-out %/, $(C)) # 取出不符合的格式的值
all:
	@echo D = $(D)  # d/
	@echo E = $(E)  # a b c
```

**wildcard函数**

取出存在的文件

```makefile
files = $(wildcard, *.c) # 在这个Makefile同级目录中，找到所有的.c文件

file1 = a.c b.c d.c 
file2 = $(wildcard $(file1)) # 取出file1中确实存在的文件
all:
	@echo files = $(files)  # # 输出这写.c文件的名字

```

**patsubst函数**

替换

```makefile
file1 = a.c b.c d.c 
file2 = $(patsubst %.c, %d, $(file1)) # 所有.c替换成.d

all:
	@echo files = $(files)  # 

```



**支持头文件的依赖的例子**

```makefile
objs = a.o b.o c.o

dep_files := $(patsubst %,.%.d, $(objs)) # objs所有项都加上.d后缀
dep_files := $(wildcard $(dep_files)) # 取出这些存在的文件

CFLAGS = -Werror -Iinclude  # 编译的选项

test: $(objs)
	gcc -o test $^

ifneq ($(dep_files),)  # 这里第二个参数是空,dep_files不是空就进行以下操作
include $(dep_files)  # 添加这些存在的依赖文件 
endif

%.o : %.c
	gcc $(CFLAGS) -c -o $@ $< -MD -MF .$@.d # 加入依赖文件

clean:
	rm *.o test

distclean:
	rm $(dep_files)   # 删除依赖文件
	
.PHONY: clean	
```

-MD -MF以后在了解







### Linux操作系统基础

**进程与线程**

**进程**

程序是静态的，进程是动态的。进程是程序的一次执行的实体，一个程序，可以有多个进程（使用记事本程序打开多个txt文档，程序执行多次，创建多个进程）。进程有一个ID号，叫做PID，父进程的ID是PPID。

进程是资源分配的基本单位

**线程**

线程是进程中执行运算的最小单位，即处理机调度的基本单位，与资源分配无关

一个线程只能属于一个进程，一个进程可以有个线程（至少一个）



linux内核完成初始化并挂载上根文件系统之后，默认启动名为init的程序。

vmlinux：严格意义上的内核，elf格式，但是不能启动

zImage：最终和映像文件，包括vmlinux、head.S、misc.c等等（.o），即引导加载程序和真正的内核



**gdb** 

gdb是一个调试工具

### 系统移植方面

学了一段时间linux，但是有点蒙，只能使用厂家提供的系统在板子上实现点灯等操作，内核移植、文件系统、Qt移植等等都是一头雾水。此篇解决他们

linux内核：linux4.9

bootloader：u-boot2017.03

文件系统：busybox1.30

buildroot2019.02

Yocto

交叉编译工具链：gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf.tar.xz

**bootloader**

下载地址：<http://www.denx.de/wiki/U-Boot/SourceCode> 

 uboot 是一个裸机代码，可以看作是一个裸机综合例程。bootloader的功能有：

- 初始化相关硬件：串口、网卡、内存、USB等等
- 把内核从flash（nand、nor、emmc、sd）读取到内存，然后跳到内核的入口，启动内核

常用的bootloader有u-boot

**根文件系统**

根文件系统首先是内核启动时所 mount(挂载)的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。根文件系统 /

根文件系统是 Linux 内核启动以后挂载(mount)的第一个文件系统，然后从根文件系统中读取初始化脚本，比如 rcS，inittab 等。根文件系统和 Linux 内核是分开的，单独的 Linux 内核是没法正常工作的，必须要搭配根文件系统。如果不提供根文件系统， Linux 内核在启动的时候就会提示内核崩溃(Kernel panic)的提示



**rcS**

Linux 内核启动以后需要启动一些服务，rcS规定启动哪些文件的脚本文件，他是一个shell脚本，/etc/init.d/rcS，创建好文件/etc/init.d/rcS 以后一定要给其可执行权限

> chmod 777 rcS

**fstab**

使用 mount 命令来挂载所有的文件系统，这些文件系统由文件/etc/fstab 来指定，
所以还要创建/etc/fstab 文件。fstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区

**inittab**

inittab 的详细内容可以参考 busybox 下的文件 examples/inittab。init 程序会读取/etc/inittab
，inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成

> ::sysinit:/etc/init.d/rcS

系统启动以后运行/etc/init.d/rcS 这个脚本文件







### 交叉编译工具链x



### 各种IP、pingx



- 



### 字节序

字节序指的是一个4字节的数据，存放在内存中的顺序。有大字节序和小字节序，一般的ARM芯片默认都是小字节序，也可以设置为大字节序

- 小（端）字节序：数据的低位保存在内存的低地址（数据低在内存低）
- 大（端）字节序：数据的高位保存在内存的低地址（数据高在内存低）

在任何平台上，都可以写一个C程序，查看机器的字节序，示例如下

```
。。。。。。。。。。。。。。。。。。。。。。
```

### 位操作

主要使用<<、>>、|、&、~。

- <<：左移，针对二进制
- \>>：右移，针对二进制
- ~：按位取反
- |：按位或
- &按位与

寄存器某位清零和某位置1的例子，可以一次置以位，也可以一次置多个位

```c
#include <stdio.h>

int main()
{
	int a = 0x147;  // 二进制为 1 0100 0111
	
	// 把bit2清零
	// (1 << 2)得到一个只有bit2是1的数
	// ~(1 << 2)得到一个只有bit2是0，其余位全是1的数
	// a & (~(1 << 2)) a与这个数按位与，把a的bit2清为0，其余不变 
	int b = a & (~(1 << 2));
	printf("b = %d\n", b);  // 1 0100 0011
	
	// bit3 置1 
	// (1 << 3)得到一个只有bit3是1，其余为0的数据 
	// a | (1 << 3)  a和这个数据按位或，bit3置为1，其余不变 
	int c = a | (1 << 3);  // 
	printf("c = %d\n", c);  // 1 0100 1111	
}
```

### 代码重定位和链接脚本

参考文档：<http://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html> 

对于2440，NAND启动时，如果程序大于4K，4K之前的程序需要把后面的程序都拷贝到内存，才能正常运行。

**程序段的概念**

段就是程序的一部分，把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段位于合适的位置。

- .text：代码段，又叫文本段，代码段其实就是函数编译后生成的东西。
- .data：数据段，初始化为非0的全局变量（注意：全局变量才算是程序的数据，局部变量不算程序的数据，只能算是函数的数据）。数据段属于静态内存分配
- .rodata：const全局变量
- .bss：BSS是英文Block Started by Symbol的简称，又叫ZI（zero initial）段，就是零初始化段，对应C语言中初始化为0的全局变量。BSS段属于静态内存分配。
- COMME：没有初值的
- 自定义段

其中，bss段和COMMEN段不保存在bin文件中



**各种地址的概念**

- 加载地址：程序从地址A搬运到地址B，地址A称为加载地址
- 存储地址：在Flash中的存储地址
- 链接地址：目标文件(.o文件)在可执行程序(bin文件)中的地址
- 运行地址：程序在内存中的地址
- 加载地址=存储地址
- 链接地址=运行地址

CPU从PC指向的地址读取指令执行（很重要），如有一条修改数据的指令存储在地址A，数据存在地址B，PC指向了地址A时候，就执行这条指令，去地址B修改这个数据，但是，在编译的时候可以指定这个数据的链接地址是C，那么程序就会去地址C处修改这个数据，为了正常的修改这个数据，要把这个数据A放到地址C上，这样才能正常读取出来再修改。那么为什么在编译的时候要指定这个数据的链接地址是C呢？默认是B 不是很好么？如果程序烧写在NOR Flash上，数据是可以像内存一样读，但是不能像内存一样写，就是能把这个地址的数据拿出来用，但是不能把其他数据写到这个地址，就像一个房子，里面东西随便用，但是别往里面放东西。这时候就要把这个数据放到一个可以修改的地方，内存！这个C地址就是内存，可以修改这个地址的数据。

此时：

- A地址叫做加载地址、存储地址
- B地址叫做数据段，
- C地址叫做链接地址，运行地址，就是要在这里才能正常运行，连接时候指定的。注意：我这里的例子ABC的地址叫的可能不太恰当，有个数据段，下次修改。

如果是NAND启动的话，片内前4K内容复制到片内SRAM，可读可写，没问题，但是如果有数据在4K以后，就不能执行了。所以无论是NOR启动还是NAND启动，都要把数据段换个能够修改的位置，都放在SDRAM中吧！这个把程序从一个地方转到另一个地方的过程就叫做“**重定位**”。



以JZ2440为例，SDRAM基地址为0X30000000，下面举几个例子：

**链接程序演示**

2.2.1 程序一

最简单链接程序

```makefile
arm-linux-ld -Ttext 0 -Tdata 0x30000000 xx1.o xx2.o -o xx.elf
```

指定代码段在0地址，数据段在0x30000000地址。编译生成的可执行程序（以下称为bin文件），会有0x30000001大小（程序中有一个全局变量），800M多（如程序中只有一个char全局变量，如果有一个int全局变量就是0x30000004），代码段在bin中的0地址，很小。数据段在0x30000000地址，这就把整个bin文件拉大了，尽管中间什么都没有，但是链接过程指定的各个.o文件在bin文件中存放的位置。

用链接脚本 .lds文件指定连接过程，各个段在bin文件中的位置等等

```
SECTIONS {
   .text   0  : { *(.text) }
   .rodata  : { *(.rodata) }
   .data 0x30000000 : AT(0x800) { *(.data) }  /* 放在地址2048 */
   .bss  : { *(.bss) *(.COMMON) }
}
```

 代码段：指定了代码段在bin文件中的位置，从地址0开始排放，*表示所有文件的代码段。排完了代码段，再接着排放只读数据段。

数据段：0x30000000指定了data段的链接地址，0x800指定了data段在bin文件中的存储地址/加载地址。指定了，data段要在0x30000000上操作，但是实际上在0x800的地方，程序就会变小。所以为了程序正常运行，要把数据段从0x800的地方复制到0x30000000，需要在程序中加入以下程序，0x800的数据复制到0x30000000，叫做重定位：





```
.data 0x30000000 : AT(0x800) 
  { 
      data_load_addr = LOADADDR(.data);

      . = ALIGN(4);   /* 4字节对齐 */
       data_start = . ;
      *(.data) 
      data_end = . ;
   }
```

```assembly
ldr r1, =data_load_addr 
ldr r2, =data_start 
ldr r3, =data_end    

cpy:
    ldr r4, [r1]
    str r4, [r2]
    add r1, r1, #4
    add r2, r2, #4

    cmp r2, r3
    ble cpy

```

LOADADDR(.data)表示.data段的加载地址，就是0x800。 

. 表示当前地址

data_start表示.data段的起始地址，data_end表示.data段的末尾地址，这个时候有个开始地址和末尾地址，就不用管数据有多少了，循环赋值就行了。

. = ALIGN(4) 表示当前地址为4字节对齐，代码段排放之后，可能不是4字节对齐的，继续排放的的话，数据也不是4字节对齐的，那就破坏了原来的4字节数据。

从加载地址0x800开始往0x30000000复制，一直到复制完，例子中，用的是字节读取和存储，太慢了，32bit CPU能4字节操作用ldr和str指令，是4字节操作。但是注意要对齐。

继续优化重定位代码，重定位所有段，使用位置无关码：

```
SECTIONS
{
 	. = 0x30000000;
 	__code_start = .;
	 . = ALIGN(4);

	 .text      :
	 {
  	   *(.text)
 	}
 	. = ALIGN(4);
 	.rodata : { *(.rodata) }
	 . = ALIGN(4);
	 .data : { *(.data) }
 	. = ALIGN(4);
	 __bss_start = .;
	 .bss : { *(.bss) *(.COMMON) }
	 _end = .;
}
```

```assembly
/* 重定位text, rodata, data段整个程序 */
mov r0, #0
ldr r1, =_start      /* 第1条指令运行时的地址 */
ldr r2, =__bss_start    /* bss段的起始地址 */
sub r2, r2, r1
bl copy2sdram  /* src, dest, len */

/* 清除BSS段 */
ldr r0, =__bss_start
ldr r1, =_end
bl clean_bss  /* start, end */

//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */
ldr pc, =main  /* 绝对跳转, 跳到SDRAM */

```

在这个链接文件中，指定了代码段是从0x30000000 开始，不管是NOR启动还是NAND启动，上后程序在0地址，重定位之前的代码，与位置无关，用位置无关码写成。

终极程序，使用C语言实现重定位，注意才C语言中使用连接脚本中的用法

```c
void copy2sdram(void)
{
       /* 要从lds文件中获得 __code_start, __bss_start
        * 然后从0地址把数据复制到__code_start
        */
   extern int __code_start, __bss_start;
   volatile unsigned int *dest = (volatile unsigned int *)&__code_start;
   volatile unsigned int *end = (volatile unsigned int *)&__bss_start;
   volatile unsigned int *src = (volatile unsigned int *)0;

   while (dest < end)
   {
       *dest++ = *src++;
   }
}

void clean_bss(void)
{
       /* 要从lds文件中获得 __bss_start, _end
        */
       extern int _end, __bss_start;

   volatile unsigned int *start = (volatile unsigned int *)&__bss_start;
   volatile unsigned int *end = (volatile unsigned int *)&_end;

   while (start <= end)
   {
    *start++ = 0;
   }

}
```

**代码重定位与位置无关码**

- 位置无关码：用mov、b、bl等指令跳转的地址，pc+相对偏移量，这样的话，没有绝对地址，都是相对于pc偏移的，这样即使运行地址和链接地址不一样也可以执行。
- 位置有关码：ldr pc, =标号，这里的标号是链接地址，重定位地址，运行地址。

写位置无关的程序：使用位置无关码，不使用绝对地址，最根本的办法是看反汇编

- 调用程序时使用B/BL相对跳转指令

- 重定位之前, 不可使用绝对地址，比如：不可访问全局变量/静态变量，   不可访问有初始值的数组(因为初始值放在rodata里，使用绝对地址来访问)

- 重定位之后, 使用绝对跳转命令跳到Runtime Addr，比如：ldr pc, =main

  ```
  SECTIONS
  {
   . = 0x30000000;
   __code_start = .;
  
   . = ALIGN(4);
   .text      :
   {
     *(.text)
   }
  
   . = ALIGN(4);
   .rodata : { *(.rodata) }
   . = ALIGN(4);
   .data : { *(.data) }
  
   . = ALIGN(4);
   __bss_start = .;
   .bss : { *(.bss) *(.COMMON) }
   _end = .;
  }
  ```

**C函数使用lds文件中的变量** 

在C函数中声明改变量为extern类型，使用时，要取址，比如：

```c
extern int abc;

int *p = &abc;  // p的值即为lds文件中abc的值
```

**扩展** 

反汇编文件中，有：

> 3000005c: eb000106  bl 3000047c <sdram_init>

不是跳转到3000047c去执行，而是一个偏移，如果程序从0x3000047c执行，当前治疗那个地址0x3000005c，则跳到0x3000047c。如果程序从0运行，当前指令地址0x5c ，就跳到0x47c运行。



### S3C2440启动方式

​S3C2440启动方式有两种：一、NOR Flash 启动；二、NAND Flash启动，就是以那个flash为程序盘来启动

**NOR Flash启动** 

NOR Flash的基地址为0，就是CPU的0地址，CPU从0地址，就是NOR的0地址读取第一条指令（4字节）开始执行，然后继续读取执行。此时片内4K的RAM地址为0x40000000

**NAND Flash启动** 

此时片内4K的RAM基地址为0，就是CPU的0地址，芯片硬件把NAND前4K内容复制到片内，然后从0地址（RAM上）开始取指执行，如果nand上的代码小于4K，就不用其他操作了，但是当nand上的程序多余4K时候，这4K的代码还得有一个功能：把整个程序读出来，放到SDRAM中，这样才能正常继续执行，这个过程叫做重定位(重新确定程序的地址),NOR是不可访问的

注：大多数ARM芯片从0地址启动，从0地址取值执行，到那时不同的启动方式，0地址是不同的。

**判别启动方式** 

​区分启动方式 ：NOR 可以像内存一样来读，但是不能像内存一样写，需要特殊的命令才能写NAND既可以像内存一样读，也可以像内存一样写，因为nand启动时，cpu的0地址是片内的ram，前4被复制到片内ram中。nand看起来是像内存一样可读可写的。写0到0地址, 再读出来，如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动否则就是nor启动

```assembly
mov r1, #0
ldr r0, [r1] /* 读出原来的值备份 */
str r1, [r1] /* 0->[0] */ 
ldr r2, [r1] /* r2=[0] */
cmp r1, r2   /* r1==r2? 如果相等表示是NAND启动 */
ldr sp, =0x40000000+4096 /* 先假设是nor启动 */
moveq sp, #4096  /* nand启动 */
streq r0, [r1]   /* 恢复原来的值 */
```

### NOR和NAND flash

- NOR：由CPU统一编址，CPU发出的地址可以直接到NOR，可以像内存一样读，但是不能像内存一样写
- NAND：CPU控制NAND控制器，NAND控制器控制NAND flash，



### 第一个裸机程序的分析

#### 点亮LED的步骤

1. 看原理图，确定控制LED的引脚
2. 看主芯片手册（英文原版）， 确定如何控制/配置IO（引脚）
3. 写代码

IO口点亮LED，有时候IO的驱动能力可能不够（电压、电流太弱）不能点亮LED，可以接一个三极管，使用IO点亮LED，很方便。这样就不用关心IO的驱动能力了，只需要关心输出的高电平还是低电平。

有的也可以使用一个外接电源和一个电阻，低电平点亮，高电平熄灭。具体看原理图，设计的时候参考其他板子

#### 关于寄存器的说明

以2440为例，2440是SoC，一块芯片包含了CPU和其他外围设备。CPU中有寄存器R0、R1、R2等等，这些是是CPU可以直接访问的，外围设备像GPIO控制器，它里面也有寄存器，例如GPACON，A端口的配置寄存器，严格意义来说他不是寄存器，不能使用名字GPACON来控制，只能使用GPACON的地址来控制，必须使用地址

#### 一个2440汇编点亮LEd的例子

led_on.S文件，配置IO为输出模式，配置IO输出低电平（低电平点亮）

```assembly
.text
.global _start

_start:

/* 配置GPF4为输出引脚
 * 把0x100写到地址0x56000050
 */
	ldr r1, =0x56000050
	ldr r0, =0x100	/* mov r0, #0x100 */
	str r0, [r1]

/* 设置GPF4输出低电平 
 * 把0写到地址0x56000054
 */
	ldr r1, =0x56000054
	ldr r0, =0	/* mov r0, #0 */
	str r0, [r1]

	/* 死循环 */
halt:
	b halt

```

Makefile文件，指定编译规则，

```makefile
all:
	arm-linux-gcc -c -o led_on.o led_on.S   # .S文件编译成.o文件
	arm-linux-ld -Ttext 0 led_on.o -o led_on.elf  # .o文件链接成.elf文件
	arm-linux-objcopy -O binary -S led_on.elf led_on.bin # .elf文件生成.bin二进制文件
	arm-linux-objdump -D led_on.elf > led_on.dis # .elf文件反汇编，得到返回文件
clean:
	rm *.bin *.o *.elf  # 删除所有中间文件和生成的文件
```

.dis 反汇编文件

```assembly
led_on.elf:     file format elf32-littlearm

Disassembly of section .text:

00000000 <_start>:
   0:	e59f1014 	ldr	r1, [pc, #20]	; 1c <.text+0x1c>
   4:	e3a00c01 	mov	r0, #256	; 0x100
   8:	e5810000 	str	r0, [r1]
   c:	e59f100c 	ldr	r1, [pc, #12]	; 20 <.text+0x20>
  10:	e3a00000 	mov	r0, #0	; 0x0
  14:	e5810000 	str	r0, [r1]

00000018 <halt>:
  18:	eafffffe 	b	18 <halt>
  1c:	56000050 	undefined
  20:	56000054 	undefined
```

ldr后面的源操作数有 = 的是当作伪指令，功能相当于mov，但是能移动的数据范围比mov大，如果这个数据在mov范围之内就使用mov移动，否则就把ldr当作读内存指令，把这个数据放到内存中，然后在读进来

反汇编文件中，第一列是地址，第二列是机器码，第三列是汇编码。

关于CPU的寄存器可以参考手册《ARM指令集E004armproc》

![](E:/githubDesktopDoc/myBook/docs/Linux/linux_img/mach_resgister.png)

有一些寄存器可以是别名，像sp、lr等等

- pc寄存器：程序计数器，把一个地址写入到sp寄存器时，程序就跳到这个地址去执行。pc的值为当前地址+8
- lr：连接寄存器，保存返回地址
- sp：栈指针寄存器

流水线：当前执行地址A的指令，同时在对地址A+4的指令进行译码，同时在读取地址A+8的指令。所以pc的值等于当前地址+8

第6行

```assembly
0:	e59f1014 	ldr	r1, [pc, #20]	; 1c <.text+0x1c>
```

此时pc=0+8=8，[pc, #20]为[8+20]=[28]=[0x1c]，这句的意思是去地址0x1c读取一个4字节数据，到寄存器r1，即0x56000050，



#### C语言点亮LED

汇编调用C函数之前，要设置栈，因为C需要栈空间（保存一些数据），应当假如区别NOR启动和NANd启动的区别

start.S

```assembly
.text
.global _start

_start:

	/* 设置内存: sp 栈 */
	ldr sp, =4096  /* nand启动 */
//	ldr sp, =0x40000000+4096  /* nor启动 */

	/* 调用main */
	bl main

halt:
	b halt
```

led.c

```c
int main()
{
	unsigned int *pGPFCON = (unsigned int *)0x56000050;
	unsigned int *pGPFDAT = (unsigned int *)0x56000054;

	/* 配置GPF4为输出引脚 */
	*pGPFCON = 0x100;
	
	/* 设置GPF4输出0 */
	*pGPFDAT = 0;

	return 0;
}
```

第3行，把数0x56000050转换为unsigned int类型的指针，0x56000050只是一个数据，要想当作寄存器使用，必须设置成指针，才能写入数据

第7行，就可以往这个地址写入数据了

##### 寄存器地址转指针

```
#define GPFCON (*(volatile unsigned long *)0x56000050) 
GPFCONG = 0x00000100; 
```

​	这句话实把0x00000100写入地址0x56000050中，就是配置GPF4为输出。“int* 数据”,可以把这个数据变成一个指针/地址（前提是内存中存在这个地址），指针变量里面保存的内容就是地址，“* 指针”或者 “* 地址” 是把这个指针指向的地址里面的数据取出来，那现在“*（int *数据）”代表的就是，把这个数据作为地址，再把这个地址里面的东西拿出来，或者把某些东西放进去，往GPFCON寄存里面写数值，就相当于往以这个数据为地址的内存空间写数值，即配置那个寄存器了，做法和汇编中直接往地址0x56000050中写入数据0x00000100是一样的。

​	再来说一下寄存器，以IO口配置寄存器GPFCON为例。GPFCON实际上不是寄存器，他只是地址0x56000050的一个名字而已。CPU中真正的寄存器寄存器只有R0,R1那些，CPU可以直接操作的。而这个GPFCON，或者这个地址0x56000050不是CPU能直接操作的，是通过内存控制器操作的。下面再说。

##### C语言内部机制

得到上面例程的反汇编代码，如下

```assembly
led.elf:     file format elf32-littlearm

Disassembly of section .text:

00000000 <_start>:
   0:	e3a0da01 	mov	sp, #4096	; 0x1000
   4:	eb000000 	bl	c <main>

00000008 <halt>:
   8:	eafffffe 	b	8 <halt>

0000000c <main>:
   c:	e1a0c00d 	mov	ip, sp
  10:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  14:	e24cb004 	sub	fp, ip, #4	; 0x4
  18:	e24dd008 	sub	sp, sp, #8	; 0x8
  1c:	e3a03456 	mov	r3, #1442840576	; 0x56000000
  20:	e2833050 	add	r3, r3, #80	; 0x50
  24:	e50b3010 	str	r3, [fp, #-16]
  28:	e3a03456 	mov	r3, #1442840576	; 0x56000000
  2c:	e2833054 	add	r3, r3, #84	; 0x54
  30:	e50b3014 	str	r3, [fp, #-20]
  34:	e51b2010 	ldr	r2, [fp, #-16]
  38:	e3a03c01 	mov	r3, #256	; 0x100
  3c:	e5823000 	str	r3, [r2]
  40:	e51b2014 	ldr	r2, [fp, #-20]
  44:	e3a03000 	mov	r3, #0	; 0x0
  48:	e5823000 	str	r3, [r2]
  4c:	e3a03000 	mov	r3, #0	; 0x0
  50:	e1a00003 	mov	r0, r3
  54:	e24bd00c 	sub	sp, fp, #12	; 0xc
  58:	e89da800 	ldmia	sp, {fp, sp, pc}
Disassembly of section .comment:

00000000 <.comment>:
   0:	43434700 	cmpmi	r3, #0	; 0x0
   4:	4728203a 	undefined
   8:	2029554e 	eorcs	r5, r9, lr, asr #10
   c:	2e342e33 	mrccs	14, 1, r2, cr4, cr3, {1}
  10:	Address 0x10 is out of bounds.
```

有一些新的汇编指令：sub、add、b、bl、stmdb、ldmia

- sub r0, r1, #4 ： r0 = r1 - 4

- add r0, r1, #4 ： r0 = r1 + 4

- BL xxx：branch and link，跳转到xxx，并且把返回地址保存在lr寄存器中，返回地址就是写一条指令的地址

- stm：写内存，多个寄存器的值写入内存

  - stm一次可以操作多个寄存器和内存，str只能操作一个寄存器或内存空间
  - stm有多种功能，过后增加(Increment After)、预先增加(Increment Before)、过后减少(Decrement  After)、预先减少(Decrement Before)
  - stm操作多个寄存器时，高编号寄存器存在高地址
    stmdb	sp!, {fp, ip, lr, pc}，sp!的!表示，sp经过自减保存，自减保存，最终sp的值为最终被修改的值。如果没有！表示sp的值不变，最终为最原始的值，
     10:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}：stmdb表示sp寄存器先自减，在保存。fp是r11、 ip是r12、 lr是r14、 pc是r15。假设sp一开始为4096，整个过程为：sp先自减变为4092，然后在4092的位置存pc，因为栈的自减的，4092是高地址，所以要存高编号寄存器；然后sp继续自减变为4088，在这个地址保存lr，然后继续自减，保存；自减，保存...直到包所有寄存器保存完。各个寄存器保存到内存的地址为：pc保存到4092、lr保存到4088、ip保存到4084、fp保存到4080

- ldm：读内存，写入多个寄存器，ldm只能操作一个（一次）寄存器，ldm也有stm相同的用法

  - 58:	e89da800 	ldmia	sp, {fp, sp, pc}：ldmia表示先读取后增加，高地址内存数据读到高编号的寄存器。整个过程为：先读取内存到寄存器，然后sp自增；继续读取数据，sp再自增....。一开始sp为4080，先把4080的数据读取到fp，sp自增为4084，4084的值读取到sp，sp自增为4088，4088的值读到pc（即pc为lr的值，可以继续往下执行），sp自增为4092，结束。sp后面没有！表示sp最终不受自增的影响，sp为4084的值，是ip的值，在程序的最开始，ip的值就是sp的值，所以最终sp为4096，指向栈顶

    ```assembly
    c:	e1a0c00d 	mov	ip, sp
    ```

  

**需要注意的是**：stm和ldm后面跟的ia等表示读取自增、自减和读内存、写内存的顺序。如有！，比如sp!，则表示最终sp的值受自增、自减的影响，为最终自增、自减后的值。如果没有，则表示sp的不受自增、自减的影响，该是什么就是什么

start.S：设置栈，调用main函数，并且把返回地址保存到lr中。设置栈的目的是：C函数使用栈，局部变量保存在栈中；保存lr等寄存器

main.c：定义两个局部变量，设置变量，return 0

##### 汇编和C函数之间的参数和返回值的传递

ATPCS规则：

- r0-r3：参数结果寄存器
- r4-r11：可能在函数中使用，在函数的入口保存，在函数的出口恢复

##### 调用C程序之前要设置堆栈

​	c函数中的局部变量会放到栈中，如果被调的函数还会调其他函数，那么调用的参数、返回地址、下一级函数的局部变量也会放到栈中。如果没有设置正确的栈，那么这些内容写入栈的时候就会把原来的内容覆盖掉了。

具体作用：

1.保存现场

​	现场，当下的状态，这个一定要记录下来的，否则被别人破坏掉之后，你就无法恢复现场了。而此处说的现场，就是指CPU运行的时候，用到了一些寄存器，比如r0,r1等等，对于这些寄存器的值，如果不保存而直接跳转到子函数中去执行，那么很可能就被其破坏了，因为其函数执行也要用到这些寄存器。
	因此，在函数调用之前，应该将这些寄存器等现场，暂时保持起来，等调用函数执行完毕返回后，再恢复现场。这样CPU就可以正确的继续执行了。

2.传递参数

​	C语言进行函数调用的时候，常常会传递给被调用的函数一些参数，对于这些C语言级别的参数，被编译器翻译成汇编语言的时候，就要找个地方存放一下，并且让被调用的函数能够访问，否则就没发实现传递参数了。对于找个地方放一下，分两种情况。
	一种情况是，本身传递的参数就很少，就可以通过寄存器传送参数。因为在前面的保存现场的动作中，已经保存好了对应的寄存器的值，那么此时，这些寄存器就是空闲的，可以供我们使用的了，那就可以放参数，而参数少的情况下，就足够存放参数了，比如参数有2个，那么就用r0和r1存放即可。（关于参数1和参数2，具体哪个放在r0，哪个放在r1，就是和APCS中的“在函数调用之间传递/返回参数”相关了，APCS中会有详细的约定。感兴趣的自己去研究。）另一种是参数太多，寄存器不够用，那么就得把多余的参数堆栈中了。即，可以用堆栈来传递所有的或寄存器放不下的那些多余的参数。

汇编中有配置r0为1，r1为2，然后调用一个C函数，两个参数，传进来的，就是1和2

### 时钟体系

看芯片手册，看时钟树，从晶振开始一直到各个控制器，需要配置那些寄存器，再看这些寄存器都怎么配置



### 串口编程

串口可以通过三根线通信，两根数据线，一根地线。发送数据时，按照数据的二进制的0和1发送低高电平。主要有

8N1：8位数据位，没有校验位，1个停止位

没有数据发送和接收的时候，两根线都是高电平，要发数据了，发送数据的芯片TXD，先发送一个低电平，接收方RXD接收到了数据信号，准备接收。发送完了数据之后，在发送一个低电平（停止位），再发送校验位（奇/偶校验，表示数据位中1的个数的奇偶）

TTL电平不适合长距离传输，RS232电平可以长距离传输

波特率：数据传输速度

配置相关寄存器



### 内存控制器SDRAM

**CPU编址方式** 

统一编址：CPU发出地址，地址到内存控制器，再到内存类设备（NORS、DRAM、网卡）、GPIO、UART等等

非统一编址：CPU发出的地址到NAND控制器。

统一编址的：CPU直接通过地址线访问

CPU把地址发送给内存控制器，内存控制器根据地址的范围，发出不同的片选信号，选中某个芯片。

s3c2440的CPU是arm920t，32位CPU，但是只用了27根地址线。每个SROM大小为128M，只用了27根线即可实现128M的寻址。



**CPU外围设备接口** 

1. GPIO门电路
2. 协议类接口：UART，IIC等
3. 内存接口：CPU的地址可以直接到内存接口的设备，NOR、内存、网卡等

NAND falsh不是内存类设备，他是受NAND控制器控制器的

**内存控制器**

CPU把地址发送给内存控制器，根据地址的区间，把数据发送给不同的外接设备（片选信号选中要操作的芯片）。内存控制器的作用是，根据CPU发出的地址范围，使能对应的芯片下面是2440的内存控制器的片选信号。![](E:/githubDesktopDoc/myBook/docs/Linux/linux_img/mach_2440_ram.png)

根据CPU发出的地址范围，发出相应的nGCS信号，选中对应的芯片

- CS：chip select
- SE：chip enable

**内存控制器的接线**

CPU根据自己的位数，内存芯片的位数，接线是不同的，以2440为例，是32bit的CPU，接线规则如下：

![](E:/githubDesktopDoc/myBook/docs/Linux/linux_img/mach_2440_ram_link.png)

1片16bit和2片8bit是一样的接线

芯片的位数表示可以对外提供的数据的位数。

- 8bit芯片：提供8bit数据，每一个地址存储一个8bit数据
- 16bit芯片：提供的是16bit的数据，每一个地址存储一个16bit数据
- 32bit芯片：提供的是32bit的数据，每一个地址存储一个32bit数据

如果现在CPU想要读取地址3上的一个字节，CPU发出的地址信号为0011，CPU的A1A0都是1，其余为0。

- 对于8bit芯片，他的A1A0，接收到了11，即3，就去地址3上读取一个数据，正好的8bit
- 对于16bit芯片，他的A1A0，接收到了01，即1，就去地址1上读取一个数据，得到的是一个16bit的数据（地址3和地址4的数据），交给内存控制器，内存控制器把地址3的一个字节挑出来返回给CPU
- 对于32bit芯片，他的A1A0，接收到了00，即0，就去地址0上读取一个数据，得到的是一个32bit数据（地址0，地址1，地址2，地址3），交给内存控制器，再由内存控制器挑出CPU要的数据。

整个过程，CPU只发出读、地址、两个信息，剩下的全部有内存控制器昨晚，不管接的是什么样子的芯片，内存控制器都能准确的把数据给CPU。

注意：地址有个概念：CPU的地址3上一个的字节，对应内存某个地址，8bit的就是地址3中的一个字节，16bit就是地址1，32bit就是地址0中的一个字节。CPU的地址，对应的是内存中的内存空间顺序。



**内存的时序**

内存芯片芯片的性能不同，需要一定的操作时序控制

![](E:/githubDesktopDoc/myBook/docs/Linux/linux_img/mach_2440_ram2.png)

比如这个图，从左往右看：2440发送地址、发送片选信号、发送读信号、等等一系列的操作过一会数据才有效，可以读取，然后释放读信号等等。这些参数都是2440根据接的内训芯片的性能设置。具体要阅读芯片手册。

**SDRAM**

参考文档《高手进阶，终极内存技术指南——完整/进阶版》



### 异常与中断

#### 异常向量表

各个异常的地址

#### 异常的处理流程

发生异常，保存当前状态，通过异常向量表跳到处理函数，恢复，继续执行

#### ARM CPU 7种工作模式

- 用户模式（usr）：正常的程序执行状态
- 系统模式（sys）：运行具有特权的操作系统任务
- 异常模式：
  - 管理模式（svc）：操作系统使用的保护模式
  - 数据访问终止模式（abt）：指令预取终止、数据访问终止
  - 未定义指令终止模式（und）：未定义的指令执行时进入该模式
  - 快速中断模式（fiq）: 处理快速中断，支持高速数据传送或通道处理
  - 中断模式（irq）: 处理普通中断

除了用户模式外的7个模式，称为特权模式（privileged mode），这六种模式下可以随便切换到其他模式。用户模式下不能直接切换到其他特权模式。

各个模式下有一些专属寄存器，例如快中断模式下，R8-R14是快终端模式自己的寄存器，是不是公用的

![](E:/githubDesktopDoc/myBook/docs/Linux/linux_img/mach_2440_ram_abnormal.png)

#### State

指令集

- ARM State：ARM指令集，每个指令4个字节
- Thumb State：Thumb指令集，每个指令2个字节，是压缩的指令集

如果内存小，可以把程序编译为Thumb指令集

#### CPSR、SPSR

- CPSR：程序状态寄存器 
- SPSR：程序状态保存寄存器

可以修改CPSR，进入其他模式

#### 中断

中断也是一种异常，写中断程序步骤如下

1. 设置中断源，能发出中断信号
2. 设置中断控制器，能发出中断到CPU
3. 设置CPU，CPSR寄存器
4. 保存当前状态
5. 分辨中断源
6. 清中断
7. 处理
8. 恢复之前的状态









