# 裸机编程基础

[TOC]



## 简单IO口的控制

IO口可以直接控制的硬件如下：

- 点亮LED
- 按键检测
- 蜂鸣器
- 单总线传感器（温度传感器DS18B20）

学会配置IO口的相关步骤，输出/输出模式，速度，上/下拉电阻等等，设置输出高低电平，检测输入高低电平等等。



## 定时器

定时器可以做以下几个实验：

- PWM，控制舵机，LED，等等
- 输入捕获
- 计时/数
- 等等

要理解中断的概念

## 数据通信

主要以下几种：

- 串口，控制传感器，数传传输等等
- IIC，控制OLED等
- SPI，控制SPI Flash
- 485通信
- CAN通信
- 其他无线通信



## 屏幕控制

各种屏幕，显示器件



## 存储器控制

EEPRPOM，各种Falsh，SD卡，内存管理



## 摄像头



## USB设备

鼠标，键盘等等



## 网络通信





## 操作系统







## 其他

### LED指示灯闪烁方案

- 方案一：直接点亮和熄灭，之间使用延迟，然后用的死循环，伪代码如下：

  ```C
  void led_blink(相关参数)
  {
  	while(1)
  	{
  		点亮LED
          延时
          熄灭LED
          延时
  		// 可以在此加一个计数变量，使得函数跳出。否则是一个死循环
  		// 或者加一个某条件的判断函数，达到条件就跳出
  	}
  }
  int main()
  {
  	...
  	led_blink(相关参数)
  	...
  }
  ```

  功能，使程序进入LED闪烁的死循环，也可以修改程序，在一定条件下跳出。这个条件可以在这个函数内部实现（内部计数器）或者while内调用某条件函数也可以。大致为：LED闪烁一次，调用某函数判断条件是否达到，如果达到就退出while，函数返回；如果没有达到，就继续循环。

  这么做的好处是：可以省下一个定时器

  案例：单片机飞控系统，如果陀螺仪各轴的倾角大于20度，认为的故障状态，LED以一定的频率闪烁，表示处于陀螺仪倾角过大状态，此时需要调整陀螺仪使其接近水平。伪代码如下：

  ```c
  led闪烁函数(相关参数)
  {
      if 根据参数形式，判断应如何闪烁
      {
          // 机体不平衡的故障
          while(1) 
          {
              点亮led
              延时
              熄灭
              延时 
                  
              调用检测陀螺仪状态函数，获取陀螺仪状态
              if 判断陀螺仪是否水平
                  // 是，就退出这个while
                  break
              else
                  // 不是
                  什么也不做，继续while等待
          }
          
      }
      else if 根据参数形式，判断应如何闪烁
          // 其他错误
      else
          //
  }
  
  int main()
  {
      // ..
      调用检测陀螺仪状态函数，获取陀螺仪状态
          if 判断陀螺仪是否水平
              // 是,正常，什么也不做，继续往下
            
          else
              // 不是
              异常，调用led闪烁函数，指明故障类型
      // .. 
  }
  ```

  这么做的好处是，可以剩下一个定时器，

- 方案二：使用定时器，定时器中断函数中，切换状态，使其闪烁。这样做的优点是，不影响其他程序段的执行。想闪烁的时候，就开启定时器，不想闪烁就关闭。

